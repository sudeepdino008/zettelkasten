<!DOCTYPE html><html><head><meta content="text/html; charset=utf-8" http-equiv="Content-Type" /><meta content="width=device-width, initial-scale=1" name="viewport" /><!--replace-start-0--><!--replace-start-5--><!--replace-start-8--><title>Rust: Generic types, traits and lifetimes - My Zettelkasten</title><!--replace-end-8--><!--replace-end-5--><!--replace-end-0--><link href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.8.7/dist/semantic.min.css" rel="stylesheet" /><link href="https://fonts.googleapis.com/css?family=Merriweather|Libre+Franklin|Roboto+Mono&amp;display=swap" rel="stylesheet" /><!--replace-start-1--><!--replace-start-4--><!--replace-start-7--><link href="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" rel="icon" /><meta content="Sudeep" name="author" /><meta content="Note that the Add has the default value of Self. We still want to keep the generic type here and not simply replace it with Self because there are cases where we might want a different Output (for example, adding Metres and Millimeters structs and returning a Millimeters struct). Use default type pa" name="description" /><link href="https://sudeepdino008.github.io/8591fa18.html" rel="canonical" /><meta content="Rust: Generic types, traits and lifetimes" property="og:title" /><meta content="My Zettelkasten" property="og:site_name" /><meta content="article" property="og:type" /><script type="application/ld+json">[]</script><style type="text/css">body{background-color:#eeeeee !important;font-family:"Libre Franklin", serif !important}body .ui.container{font-family:"Libre Franklin", serif !important}body h1, h2, h3, h4, h5, h6, .ui.header, .headerFont{font-family:"Merriweather", sans-serif !important}body code, pre, tt, .monoFont{font-family:"Roboto Mono","SFMono-Regular","Menlo","Monaco","Consolas","Liberation Mono","Courier New", monospace !important}body div.z-index p.info{color:#808080}body div.z-index ul{list-style-type:square;padding-left:1.5em}body div.z-index .uplinks{margin-left:0.29999em}body .zettel-content h1#title-h1{background-color:rgba(165,103,63,0.1)}body nav.bottomPane{background-color:rgba(165,103,63,2.0e-2)}body div#footnotes{border-top-color:#a5673f}body p{line-height:150%}body img{max-width:100%}body .deemphasized{font-size:0.94999em}body .deemphasized:hover{opacity:1}body .deemphasized:not(:hover){opacity:0.69999}body .deemphasized:not(:hover) a{color:#808080 !important}body div.container.universe{padding-top:1em}body div.zettel-view ul{padding-left:1.5em;list-style-type:square}body div.zettel-view .pandoc .highlight{background-color:#ffff00}body div.zettel-view .pandoc .ui.disabled.fitted.checkbox{margin-right:0.29999em;vertical-align:middle}body div.zettel-view .zettel-content .metadata{margin-top:1em}body div.zettel-view .zettel-content .metadata div.date{text-align:center;color:#808080}body div.zettel-view .zettel-content h1{padding-top:0.2em;padding-bottom:0.2em;text-align:center}body div.zettel-view .zettel-content h2{border-bottom:solid 1px #4682b4;margin-bottom:0.5em}body div.zettel-view .zettel-content h3{margin:0px 0px 0.4em 0px}body div.zettel-view .zettel-content h4{opacity:0.8}body div.zettel-view .zettel-content div#footnotes{margin-top:4em;border-top-style:groove;border-top-width:2px;font-size:0.9em}body div.zettel-view .zettel-content div#footnotes ol > li > p:only-of-type{display:inline;margin-right:0.5em}body div.zettel-view .zettel-content aside.footnote-inline{width:30%;padding-left:15px;margin-left:15px;float:right;background-color:#d3d3d3}body div.zettel-view .zettel-content .overflows{overflow:auto}body div.zettel-view .zettel-content code{margin:auto auto auto auto;font-size:100%}body div.zettel-view .zettel-content p code, li code, ol code{padding:0.2em 0.2em 0.2em 0.2em;background-color:#f5f2f0}body div.zettel-view .zettel-content pre{overflow:auto}body div.zettel-view .zettel-content dl dt{font-weight:bold}body div.zettel-view .zettel-content blockquote{background-color:#f9f9f9;border-left:solid 10px #cccccc;margin:1.5em 0px 1.5em 0px;padding:0.5em 10px 0.5em 10px}body div.zettel-view .zettel-content.raw{background-color:#dddddd}body .ui.label.zettel-tag{color:#000000}body .ui.label.zettel-tag a{color:#000000}body nav.bottomPane ul.backlinks > li{padding-bottom:0.4em;list-style-type:disc}body nav.bottomPane ul.context-list > li{list-style-type:lower-roman}body .footer-version img{-webkit-filter:grayscale(100%);-moz-filter:grayscale(100%);-ms-filter:grayscale(100%);-o-filter:grayscale(100%);filter:grayscale(100%)}body .footer-version img:hover{-webkit-filter:grayscale(0%);-moz-filter:grayscale(0%);-ms-filter:grayscale(0%);-o-filter:grayscale(0%);filter:grayscale(0%)}body .footer-version, .footer-version a, .footer-version a:visited{color:#808080}body .footer-version a{font-weight:bold}body .footer-version{margin-top:1em !important;font-size:0.69999em}@media only screen and (max-width: 768px){body div#zettel-container{margin-left:0.4em !important;margin-right:0.4em !important}}body span.zettel-link-container span.zettel-link a{color:#a5673f;font-weight:bold;text-decoration:none}body span.zettel-link-container span.zettel-link a:hover{background-color:rgba(165,103,63,0.1)}body span.zettel-link-container span.extra{color:auto}body span.zettel-link-container.errors{border:solid 1px #ff0000}body span.zettel-link-container.errors span.zettel-link a:hover{text-decoration:none !important;cursor:not-allowed}body [data-tooltip]:after{font-size:0.69999em}body div.tag-tree div.node{font-weight:bold}body div.tag-tree div.node a.inactive{color:#555555}body .tree.flipped{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}body .tree{overflow:auto}body .tree ul.root{padding-top:0px;margin-top:0px}body .tree ul{position:relative;padding:1em 0px 0px 0px;white-space:nowrap;margin:0px auto 0px auto;text-align:center}body .tree ul::after{content:"";display:table;clear:both}body .tree ul:last-child{padding-bottom:0.1em}body .tree li{display:inline-block;vertical-align:top;text-align:center;list-style-type:none;position:relative;padding:1em 0.5em 0em 0.5em}body .tree li::before{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{content:"";position:absolute;top:0px;right:50%;border-top:solid 2px #cccccc;width:50%;height:1.19999em}body .tree li::after{right:auto;left:50%;border-left:solid 2px #cccccc}body .tree li:only-child{padding-top:0em}body .tree li:only-child::after{display:none}body .tree li:only-child::before{display:none}body .tree li:first-child::before{border-style:none;border-width:0px}body .tree li:first-child::after{border-radius:5px 0px 0px 0px}body .tree li:last-child::after{border-style:none;border-width:0px}body .tree li:last-child::before{border-right:solid 2px #cccccc;border-radius:0px 5px 0px 0px}body .tree ul ul::before{content:"";position:absolute;top:0px;left:50%;border-left:solid 2px #cccccc;width:0px;height:1.19999em}body .tree li div.forest-link{border:solid 2px #cccccc;padding:0.2em 0.29999em 0.2em 0.29999em;text-decoration:none;display:inline-block;border-radius:5px 5px 5px 5px;color:#333333;position:relative;top:2px}body .tree.flipped li div.forest-link{-webkit-transform:rotate(180deg);-moz-transform:rotate(180deg);-ms-transform:rotate(180deg);-o-transform:rotate(180deg);transform:rotate(180deg)}</style><!-- Font  -->
<!-- TODO: neuron has changed default font, remove it later  -->
<link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&#38;display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,400;0,700;1,400;1,600&#38;display=swap" rel="stylesheet">

<!-- mermaidjs -->
<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
window.addEventListener("load", mermaid.initialize({startOnLoad:true}))
</script>

<!-- graphviz -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js" integrity="sha512-vnRdmX8ZxbU+IhA2gLhZqXkX1neJISG10xy0iP0WauuClu3AIMknxyDjYHEpEhi8fTZPyOCWgqUCnEafDB/jVQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js" integrity="sha512-1zKK2bG3QY2JaUPpfHZDUMe3dwBwFdCDwXQ01GrKSd+/l0hqPbF+aak66zYPUZtn+o2JYi1mjXAqy5mW04v3iA==" crossorigin="anonymous"></script>
<script>
window.addEventListener("load", function(){
  let viz = new Viz();
  for (let element of document.getElementsByClassName("graphviz")) {
    let parent = element.parentNode
    let pparent = parent.parentNode
    viz.renderSVGElement(element.textContent)
    .then(function(element) {
      element.setAttribute("width", "100%")
      pparent.replaceChild(element, parent)
    });
  }
});
</script>

<!-- chartjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.bundle.min.js" integrity="sha512-SuxO9djzjML6b9w9/I07IWnLnQhgyYVSpHZx0JV97kGBfTIsUYlWflyuW4ypnvhBrslz1yJ3R+S14fdCWmSmSA==" crossorigin="anonymous"></script>
<script>
window.addEventListener("load", function(){
  for (let element of document.getElementsByClassName("chartjs")) {
    let parent = element.parentNode
    let pparent = parent.parentNode
    let canvas = document.createElement('canvas');
    let box = document.createElement('div');
    box.appendChild(canvas);
    let ctx = canvas.getContext("2d")
    let myChart = new Chart(ctx, JSON.parse(element.textContent));
    box.setAttribute("style","display:block;width:75%;text-align:'center';margin: 5px auto;");
    pparent.replaceChild(box, parent)
  }
});
</script>

<!-- Custom css  -->
<style>

  
img[src$="centerme"] {
  display:block;
  margin: 0 auto;
}

ui.menu {
  font-size: 0.6em;
}

/* tree icon disappear some times*/
body .tree {
  overflow: hidden;
}

/* width */
.ui.text.container {
    min-width: 1000px;
}

@media screen and (min-width: 700px) {
    .ui.attached.segment {
      padding: 50px;
    }
}

* {
  font-size: 17px;
}

body div.zettel-view .zettel-content h1 {
  font-family: "Crimson Text", serif !important;
  font-weight: 600 !important;
  padding: 0.3rem !important;
  border-bottom: none;
  text-align: left;
  background-color: inherit !important;
}

body div.zettel-view .zettel-content h2 {
  font-family: "Crimson Text", serif !important;
  font-weight: 600 !important;
  padding: 0.3rem !important;
  font-size: 1.75rem !important;
  border-bottom: none;
  text-align: left;
  background-color: inherit !important;
}


body div.zettel-view .zettel-content h3 {
  font-family: "Crimson Text", serif !important;
  font-weight: 600 !important;
  padding: 0.3rem !important;
  font-size: 1.5rem !important;
  border-bottom: none;
  text-align: left;
  background-color: inherit !important;
}

body div.zettel-view .zettel-content h4 {
  font-family: "Crimson Text", serif !important;
  font-weight: 600 !important;
  font-size: 1.25rem !important;
  padding: 0.3rem !important;
  border-bottom: none;
  text-align: left;
  background-color: inherit !important;
}

/* title */
#zettel-container > div.zettel-view > article > h1:first-child {
/* body div#neuron-theme-default-black .zettel-content h1 { */
  /* text-align: center !important; */
  font-family: "Crimson Text", serif !important;
  /* font-style: italic; */
  text-align: right;
  font-weight: normal !important;
  font-size: 2rem;
  padding: 1rem;
  /* padding-top: 1rem; */
  /* padding-right: 1rem; */
  /* padding-left: 1rem; */
  background-color: inherit !important;
}

#neuron-theme-default-black > div > h1 {
  font-family: "Crimson Text", serif !important;
  font-weight: normal;
}

/* divider */
.ui.horizontal.divider:before {
  width: 100%;
}

/* logo */
div.ui.one.column.grid.footer-version > div > div > a > img {
  display:none !important;
}

div.ui.one.column.grid.footer-version > div > div > a:before {
  content: "© 2020 shifuda" !important;
  font-size: 0.8rem;
}

/* link */
body div#neuron-theme-default-black span.zettel-link-container span.zettel-link a {
  color: inherit !important;
}

time {
  font-family: "Crimson Text", monospace !important;
}

body code, pre, tt {
  font-family: "Source Code Pro", monospace !important;
}

.ui.text.container {
  font-family: "Crimson Text", serif !important;
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

</style>
<!--replace-end-7--><!--replace-end-4--><!--replace-end-1--></head><body><div class="ui fluid container universe"><!--replace-start-2--><!--replace-start-3--><!--replace-start-6--><div class="ui text container" id="zettel-container" style="position: relative"><div class="zettel-view"><article class="ui raised attached segment zettel-content"><div class="pandoc"><h1 id="title-h1">Rust: Generic types, traits and lifetimes</h1><h2 id="generic-types">generic types</h2><ul><li>using generic types in function prototype</li><li>this example includes trait bounds: <code>&lt;T: PartialOrdering&gt;</code></li></ul><pre><code class="language-none">// in function
fn largest&lt;T: PartialOrdering&gt;(list: &amp;[T]) -&gt; T

// in struct
struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

// in method definitions
impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

// in enum definitions
enum Option&lt;T&gt; {
    Some(T),
    None,
}
</code></pre><ul><li>To implements generics by <em>monomorphization</em> of code, which generates various concrete types as need at compile time (similar to c++ templates). Hence generic types have no runtime costs.</li><li>default generic type parameters: specify a default concrete type for the generic type. This eliminates the need for specifying the type when the default type works. The syntax is <code>&lt;PlaceholderType=ConcreteType&gt;</code>. This is called default type parameters. An example is with operator overloading.</li></ul><pre><code class="rust language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

// definition of Add trait
trait Add&lt;Rhs=Self&gt; {
    type Output;

    fn add(self, rhs: Rhs) -&gt; Self::Output;
}</code></pre><p>Note that the <code>Add</code> has the default value of Self. We still want to keep the generic type here and not simply replace it with Self because there are cases where we might want a different <code>Output</code> (for example, adding Metres and Millimeters structs and returning a Millimeters struct). Use default type parameters in two main ways:</p><ul><li><p>to extend a type without breaking existing code</p></li><li><p>to allow customization in specific cases most users won’t need.</p></li><li><p>associated types might seem similar to generics. The difference is that with generics, multiple implementations are created while with associated types we only choose the type once. For example, <code>Iterator</code> uses associated types and you don’t have to specify the type when you call <code>next</code></p></li></ul><h2 id="traits">traits</h2><ul><li>defining shared behaviour. Similar to <em>interfaces</em> in other languages although with some differences (??)</li></ul><pre><code class="rust language-rust">//defining a trait
trait Summary {
    fn summarize(&amp;self) -&gt; String;
    
    // default implementation
    fn summarize2(&amp;self) -&gt; String {
        String::from(&quot;useless summary here&quot;)
    }
}


// implementing a trait
impl &lt;trait-name&gt; for &lt;struct-name&gt; {
    &lt;body&gt;
}

// default implementations

</code></pre><ul><li><p>when implementing a trait, note that either the trait or the struct should be internal (belong to you). Without this rule two crates could implement the same trait for the same type, and Rust couldn’t know which impl to use.</p></li><li><p>traits as parameters and return type: trait bound (has more expressibility) and impl trait (simpler in some cases)</p></li></ul><pre><code class="rust language-rust">
// impl trait syntax
fn notify(item: &amp;impl Summary) {
    //blahblah
}

// trait bound syntax
fn notify&lt;T: Summary&gt;(item: &amp;T) {
    //same blahbha
}

// for multiple traits
fn notify(item: &amp;(impl Summary + Display)) {}

fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}

</code></pre><ul><li><code>where</code> clauses: for cases where too many generics and trait bounds are involved.</li></ul><pre><code class="rust language-rust">
fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32 
    where T: Display + Clone,
          U: Clone + Debug
{
  //..
}
</code></pre><ul><li>However, you can only use impl Trait if you’re returning a single type. For example, this code that returns either a NewsArticle or a Tweet with the return type specified as impl Summary wouldn’t work:</li></ul><pre><code class="rust language-rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {}
}

pub struct Tweet {}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {}
}

fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {}
    } else {
        Tweet {}
    }
}
</code></pre><ul><li>conditionally implement methods with trait bounds</li></ul><pre><code class="rust language-rust">// here special_func is only available for structs which are associated 
// with T which is trait bound by trait1 and trait2
impl&lt;T: trait1 + trait2&gt; StructName&lt;T&gt; {
    fn special_func() {}
}

// blanket implementations: conditionally implement a trait 
// for type which implements another trait
impl&lt;T: Display&gt; ToString for T {

}
</code></pre><h3 id="fully-qualified-syntax-for-disambiguation-calling-methods-with-same-name">fully qualified syntax for disambiguation: calling methods with same name</h3><ul><li>when methods have same name across different traits or implementation, we use fully qualified syntax to disambiguate:</li></ul><pre><code class="rust language-rust">fn adv_traits() {
    trait Pilot {
        fn fly(&amp;self);
        fn bottomline();
    }

    struct Human;

    impl Pilot for Human {
        fn fly(&amp;self) {
            println!(&quot;pilot&quot;);
        }

        fn bottomline() {
            println!(&quot;pilot bottomline&quot;);
        }
    }

    impl Human {
        fn fly(&amp;self) {
            println!(&quot;human&quot;);
        }

        fn bottomline() {
            println!(&quot;human bottomline&quot;);
        }
    }

    let person = Human;
    Pilot::fly(&amp;person); // Pilot text
    &lt;Human as Pilot&gt;::fly(&amp;person); // Pilot text
    person.fly(); // Human text

    Human::bottomline(); // human bottomline
    &lt;Human as Pilot&gt;::bottomline(); // pilot bottomline
}
</code></pre><h3 id="supertraits">supertraits</h3><p>to require one trait’s functionality within another trait</p><pre><code class="rust language-rust">
fn supertrait() {
    trait UselessDisplay: fmt::Display {
        fn useless_display(&amp;self) {
            println!(&quot;{}&quot;, self.to_string());
        }
    }

    struct Point {
        x: i32,
        y: i32,
    }

    impl fmt::Display for Point {
        fn fmt(&amp;self, f: &amp;mut Formatter&lt;&#39;_&gt;) -&gt; fmt::Result {
            write!(f, &quot;({}, {})&quot;, self.x, self.y)
        }
    }

    impl UselessDisplay for Point {}

    let p = Point { x: 10, y: 20 };
    p.useless_display();
}</code></pre><h3 id="newtype-pattern">newtype pattern</h3><p>orphan rule: you can only implement traits when either the type or the trait is local to your crate.<br />It’s possible to get around this restriction using newtypes pattern - this involves creating a new type in tuple struct</p><p>example: implement <code>Display</code> on <code>Vec&lt;T&gt;</code>. Note that this is not possible because of the orphan rule. But we can use newtypes pattern to get around it.</p><pre><code class="rust language-rust">fn newtype_pattern() {
    struct Wrapper(Vec&lt;String&gt;);

    impl fmt::Display for Wrapper {
        fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
            write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
        }
    }

    let w = Wrapper(vec![String::from(&quot;jdfkj&quot;), String::from(&quot;ere3&quot;)]);
    println!(&quot;w = {}&quot;, w);

    // you can expose the Vec functions to Wrapper using deref coercion

    impl Deref for Wrapper {
        type Target = Vec&lt;String&gt;;

        fn deref(&amp;self) -&gt; &amp;Self::Target {
            &amp;self.0
        }
    }

    println!(&quot;w length = {}&quot;, w.len());
}
</code></pre><ul><li>newtypes are also useful to abstract away some implementation details of a type, and expose a different public API.</li></ul><h2 id="lifetimes">lifetimes</h2><ul><li>it’s about connecting the lifetime (scope is another way to think about it) of various parameters. Lifetimes are a type of generic</li></ul><pre><code class="rust language-rust">fn lifetime() {
    let str1 = String::from(&quot;GG&quot;);
    let str2 = String::from(&quot;wassup&quot;);
    let lar_str = largest_str(&amp;str1, &amp;str2);
    println!(&quot;largest string is {}&quot;, lar_str);
}

fn largest_str&lt;&#39;a&gt;(str1: &amp;&#39;a str, str2: &amp;&#39;a str) -&gt; &amp;&#39;a str {
    if str1.len() &gt; str2.len() {
        str1
    } else {
        str2
    }
}
</code></pre><ul><li>when structs need to hold references, we’ve to specify lifetimes</li></ul><pre><code class="rust language-rust">struct ImportantExcerpt&lt;&#39;a&gt; {
    part: &amp;&#39;a str,
}</code></pre><h3 id="lifetime-elision"><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">lifetime elision</a></h3><ul><li><p>there are some predictable lifetime patterns in lifetime which have been programmed into the compiler’s code so the borrow checker can infer the lifetimes in these situations and won’t need explicity annotations. These are called <strong>lifetime elision rules</strong>.</p></li><li><p>In case lifetime elision are not good enough to identify the lifetime of some parameter, the compiler throws error.</p></li><li><p>input lifetimes: lifetimes on function or method parameters<br />output lifetimes: lifetimes on return values.</p></li><li><p>There are 3 rules that apply to <code>fn</code> definitions as well as impl blocks.</p><ol><li>each parameter gets its own lifetime parameter.</li><li>if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></li><li>if there are multiple input lifetime parameters, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code> is assigned to all output lifetime parameters.</li></ol></li><li><p>static lifetime: the reference you’ve specified <em>can</em> live for the entire lifetime of your program. But it’s possible that it doesn’t:</p></li></ul><pre><code class="rust language-rust">let x: &amp;`static i32`</code></pre></div><div class="metadata"><div class="date" title="Zettel date"><time datetime="2021-05-17T20:04">2021-05-17</time></div></div></article><nav class="ui attached segment deemphasized backlinksPane" id="neuron-backlinks-pane"><h3 class="ui header">Backlinks</h3><ul class="backlinks"><li><span class="zettel-link-container cf"><span class="zettel-link" title="2021-05-16T20:56"><a href="2584752a.html">Rust</a></span></span><ul class="context-list" style="zoom: 85%;"></ul></li></ul></nav><nav class="ui attached segment deemphasized bottomPane" id="neuron-tags-pane"><div><span class="ui basic label zettel-tag" title="Tag">rust</span></div></nav><nav class="ui bottom attached icon compact inverted menu brown" id="neuron-nav-bar"><!--replace-start-9--><a class="item" href="." title="Home"><i class="home icon"></i></a><!--replace-end-9--><a class="right item" href="impulse.html" title="Open Impulse"><i class="wave square icon"></i></a></nav></div></div><!--replace-end-6--><!--replace-end-3--><!--replace-end-2--><div class="ui center aligned container footer-version"><div class="ui tiny image"><a href="https://neuron.zettel.page"><img alt="logo" src="https://raw.githubusercontent.com/srid/neuron/master/assets/neuron.svg" title="Generated by Neuron 1.9.27.0" /></a></div></div></div></body></html>