---
date: 2021-05-16T16:09
---

# Cryptocurrency: Hashing


## cryptographic hash functions
- **definition**: digital fingerprint of data
`h(x) -> digest`  
- Here `x` is some arbitrary input, while digest is a fixed length output generated by the hash function `h`.
- hash maps, data distrubution algorithms etc. are all powered by hashing.

- properties:
  - has to be fast
  - has to be deterministic (same output for a data x)
  - preimage resistant (one-way): infeasible to get x from Hash(x)
  - collision resistant: infeasible to find x and y such that Hash(x) == Hash(y)
  - avalanche effect: for a slight change in data, the Hash changes dramatically
  - cryptocurrencies need an additional property: puzzle friendly, i.e. the only way to find a hash with a specific property is brute force. There are no shortcuts.
- Bitcoin hash functions:
  - headers and merkle trees: SHA-256
  - bitcoin adresses: SHA-256 and RIPEMD160: making it much more difficult to crack.
  
- different hash functions have different properties



### finding collisions
- `h(x)` has been broken (collisions can be found in a way significantly faster than brute force). Examples include [SHA-1](https://shattered.io/), MD5



#### an example use case of hash function: commitment scheme
- commit to a statement publically, but only reveal the actual message afterwards.
- Steps are:
  - `com = commit(msg, nonce)` where `commit` is a hash function
  - declare com publically
  - at a later date, you can reveal msg and nonce, and anyone can verify that it was the actual message you published back then.



## hash pointers
- regular pointers + hash information of data at that location.
- this helps in verify data present at the pointer.
- hash pointers make regular data structures (using pointers) tamper resistant.
- example: linked list with hash pointer (a basic blockchain) - hash of a block is generated from data of the current node + hash of the previous node.
- hash pointers cannot be used with array like data structures or cyclic data structures.

### Merkle trees
- binary trees with hash pointers
- how does it work in bitcoin (??)
- proving membership takes O(log n) (??)
- in bitcoin, the merkle root in a block is the merkle root of all the transactions in that block
- it allows mining to be equally difficult no matter how many transactions are included in it.
- more transactions fees for miners => incentives



### asymmetric key and digital signatures
#### digital signature algorithms
- Generate key pair: public key (pk) and private key (sk) - from random number (uses elliptic curve digital signature algorithm (EDCSA)... y^2 = x^3 + 7)
- signature - creates digital signature (Sig) from message (m) and private key (sk)
- verification - verifies if a signature (Sig) is valid for a message (m) and a public key (pk).


#### properties
- infeasible to find private key (sk) from public key (pk).


