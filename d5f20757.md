---
date: 2021-05-12T08:31
---

# Rust: Ownership

Ownership: Managing heal data  
- Rust uses something similar to RAII where a "drop" is added at the end of the function (or when it goes out of scope) to release the heap memory used.
- String literal is allcoated on stack (as it's fixed size) whereas String is allocated on heap.
```rust
let s = String::from("hello");  //"hello" is a string literal
```
- Entities which implement "Drop" have reference to some data in the heap. Move semantics are used in assignment, function calls or function returns.
```rust
let s1 = String::from("hello");
let s2 = s1;
// s1 is no longer valid here, using it will return in error
// the ownership of the heap data storing the string is now with s2.
// this avoids the "double free" problem
```

- Copy trait: performs a shallow copy i.e. only data in stack is copied.
  - Simply copies the bytes pointed to be the variable.
  - So if a class implements Copy trait with a reference to a String, "copy" will simply copy the reference of the String into the new Class instance. The heap data won't be copied.
  - It's different from the move semantics in that the earlier variable is still valid.
  - Note that this could lead to "double drop" problem, so in general a type cannot be annotated by Copy trait if it already is annotated by Drop.
  - Some types that do implement copy are: scalar types and tuples composed solely of scalar types.

- Clone trait: explicit function which needs to be defined by the user. Might be used to do a deep clone. This will be expensive.

- Stack unwinding: The stack variables are popped off the stack in the reverse order to which they were added.


## References and borrowing

Ownership transfer in function calls can be inconvenient. We need to return the variable back to transfer the ownership back, this is not a good solution.  
Instead, you can "borrow" - have function parameters as references instead of transferring ownership.

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

**Mutable reference**: you need to create mutable reference if the function intends to change the underlying data. Rust also handles data races by the following restriction - you cannot have a immutable reference and a mutable reference in the same scope. Oh, and data races can happen when these 3 behaviour occur:
- two or more pointers access the same data at the same time.
- one of them is being used to edit/write the data
- there's no synchronization for accessing the data.


```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &s; // no problem
    let r2 = &s; // no problem
    println!("{} and {}", r1, r2);
    // r1 and r2 are no longer used after this point

    let r3 = &mut s; // no problem
    println!("{}", r3);
}

```

Dangling references: a pointer that references a location in memory, but that location has already been freed. In rust, the compiler guarantees that there won't be any dangling references.  
For example, this would lead to error:

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello"); // s is a new string

    &s // a reference to s is returned here
}  // s goes out of scope, freeing the memory. Any reference to the pointer returned here will lead to dangling pointer error. DANGER!
```
